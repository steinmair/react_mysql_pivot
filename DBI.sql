use school;

    -- MATURA

    -- DBI 50%: 2,5 Stunden
    -- SQL QUERY /join/ group-by/ subquery 14/50 Punkte
    -- ER SCHEMA / text to ER ( entität-relationen modell )  / ER to relationen schema tabelle
    -- Normalisierung
    -- Fragen Transaktionen / Constraints / Isolationsgrade / Lockings

    -- POS 50%:
    -- MVC 80%
    -- Master Detail
    -- Single
    -- Controller
    -- Instanzmethoden
    -- Layout / visualisierung
    -- Tuning 20% / Entity
    -- Fragen
    -- REST 20%

-- Zeil
-- Zwischensumme pro schulklasse
-- Zwischensumme pro Abteilung
-- gesamtsumme
-- select muss in groupby vorhanden sein

SELECT SCHOOLCLASS.DEPARTMENT_ID, DEPARTMENT.NAME_SHORT NAME_DEP,
       STUDENT.SCHOOLCLASS_ID, SCHOOLCLASS.NAME NAME_SC,
       (CASE WHEN STUDENT.SEX IS NOT NULL THEN SEX
        WHEN STUDENT.SEX IS NULL AND STUDENT.SCHOOLCLASS_ID IS NOT NULL THEN 'Anzahl Schulklasse'
         ELSE '' END ) SEX,
    -- (CASE WHEN SCHOOLCLASS.NAME IS NOT NULL THEN NAME
      --    WHEN SCHOOLCLASS.NAME IS NULL AND SCHOOLCLASS.SCHOOLCLASS_ID IS NULL THEN 'Anzahl Abteilung'
        -- ELSE '' END ) NAME_SC,
       -- IFNULL(STUDENT.SEX,'Anzahl Schulklasse') SEX,
       COUNT(*) CNT,
       GROUPING(SCHOOLCLASS.DEPARTMENT_ID,DEPARTMENT.NAME_SHORT,
         STUDENT.SCHOOLCLASS_ID,SCHOOLCLASS.NAME,STUDENT.SEX) GROUPING_ID
FROM STUDENT,
     SCHOOLCLASS,
     DEPARTMENT
WHERE STUDENT.SCHOOLCLASS_ID = SCHOOLCLASS.SCHOOLCLASS_ID
AND SCHOOLCLASS.DEPARTMENT_ID = DEPARTMENT.DEPARTMENT_ID
GROUP BY SCHOOLCLASS.DEPARTMENT_ID,DEPARTMENT.NAME_SHORT,
         STUDENT.SCHOOLCLASS_ID,SCHOOLCLASS.NAME,STUDENT.SEX WITH ROLLUP
HAVING GROUPING_ID NOT IN (3,15,31);
-- ORDER BY SCHOOLCLASS.DEPARTMENT_ID,STUDENT.SCHOOLCLASS_ID,STUDENT.SEX;

SELECT SCHOOLCLASS.DEPARTMENT_ID,
    STUDENT.SCHOOLCLASS_ID,SCHOOLCLASS.NAME NAME_SC,
    COUNT(*) CNT,
    DENSE_RANK() OVER (PARTITION BY DEPARTMENT_ID ORDER BY COUNT(*)) RANKING1
FROM STUDENT,
     SCHOOLCLASS
WHERE STUDENT.SCHOOLCLASS_ID = SCHOOLCLASS.SCHOOLCLASS_ID
GROUP BY SCHOOLCLASS.DEPARTMENT_ID,STUDENT.SCHOOLCLASS_ID,SCHOOLCLASS.NAME
ORDER BY SCHOOLCLASS.DEPARTMENT_ID,SCHOOLCLASS.NAME;


SELECT SCHOOLCLASS.DEPARTMENT_ID,
    STUDENT.SCHOOLCLASS_ID,SCHOOLCLASS.NAME NAME_SC,
    COUNT(*) CNT,
    AVG(COUNT(*)) OVER (PARTITION BY DEPARTMENT_ID) AVG
FROM STUDENT,
     SCHOOLCLASS
WHERE STUDENT.SCHOOLCLASS_ID = SCHOOLCLASS.SCHOOLCLASS_ID
GROUP BY SCHOOLCLASS.DEPARTMENT_ID,STUDENT.SCHOOLCLASS_ID,SCHOOLCLASS.NAME
ORDER BY SCHOOLCLASS.DEPARTMENT_ID,SCHOOLCLASS.NAME;

SELECT SCHOOLCLASS.DEPARTMENT_ID,
    STUDENT.SCHOOLCLASS_ID,SCHOOLCLASS.NAME NAME_SC,
    COUNT(*) CNT,
    SUM(COUNT(*)) OVER (PARTITION BY DEPARTMENT_ID) SUM
FROM STUDENT,
     SCHOOLCLASS
WHERE STUDENT.SCHOOLCLASS_ID = SCHOOLCLASS.SCHOOLCLASS_ID
GROUP BY SCHOOLCLASS.DEPARTMENT_ID,STUDENT.SCHOOLCLASS_ID,SCHOOLCLASS.NAME
ORDER BY SCHOOLCLASS.DEPARTMENT_ID,SCHOOLCLASS.NAME;

SELECT SCHOOLCLASS.DEPARTMENT_ID,
    STUDENT.SCHOOLCLASS_ID,SCHOOLCLASS.NAME NAME_SC,
    COUNT(*) CNT,
    MIN(COUNT(*)) OVER (PARTITION BY DEPARTMENT_ID) MIN,
    MAX(COUNT(*)) OVER (PARTITION BY DEPARTMENT_ID) MAX
FROM STUDENT,
     SCHOOLCLASS
WHERE STUDENT.SCHOOLCLASS_ID = SCHOOLCLASS.SCHOOLCLASS_ID
GROUP BY SCHOOLCLASS.DEPARTMENT_ID,STUDENT.SCHOOLCLASS_ID,SCHOOLCLASS.NAME
ORDER BY SCHOOLCLASS.DEPARTMENT_ID,SCHOOLCLASS.NAME;

SELECT SCHOOLCLASS.DEPARTMENT_ID,
    STUDENT.SCHOOLCLASS_ID,SCHOOLCLASS.NAME NAME_SC,
    COUNT(*) CNT,
    SUM(COUNT(*)) OVER (PARTITION BY DEPARTMENT_ID) SUM,
    100 * COUNT(*) / (SUM(COUNT(*)) OVER (PARTITION BY DEPARTMENT_ID)) PERCENT1, -- pro department
    100 * COUNT(*) / (SUM(COUNT(*)) OVER ()) PERCENT2, -- gesamtanzahl OVER leer
    MIN(COUNT(*)) OVER (PARTITION BY DEPARTMENT_ID) MIN,
    MAX(COUNT(*)) OVER (PARTITION BY DEPARTMENT_ID) MAX
FROM STUDENT,
     SCHOOLCLASS
WHERE STUDENT.SCHOOLCLASS_ID = SCHOOLCLASS.SCHOOLCLASS_ID
GROUP BY SCHOOLCLASS.DEPARTMENT_ID,STUDENT.SCHOOLCLASS_ID,SCHOOLCLASS.NAME
ORDER BY SCHOOLCLASS.DEPARTMENT_ID,SCHOOLCLASS.NAME;

SELECT SCHOOLCLASS.DEPARTMENT_ID,
    STUDENT.SCHOOLCLASS_ID,SCHOOLCLASS.NAME NAME_SC,
    COUNT(*) CNT,
    LEAD(COUNT(*)) over (PARTITION BY DEPARTMENT_ID ORDER BY COUNT(*)) LEAD1,
    (LEAD(COUNT(*)) over (PARTITION BY DEPARTMENT_ID ORDER BY COUNT(*)) / COUNT(*)-1) * 100 PERCENT3,
    LAG(COUNT(*)) over (PARTITION BY DEPARTMENT_ID ORDER BY COUNT(*)) LAG1,
    RANK() over (PARTITION BY DEPARTMENT_ID ORDER BY COUNT(*)) Ranking1,
    SUM(COUNT(*)) OVER (PARTITION BY DEPARTMENT_ID) SUM,
    100 * COUNT(*) / (SUM(COUNT(*)) OVER (PARTITION BY DEPARTMENT_ID)) PERCENT1, -- pro department
    100 * COUNT(*) / (SUM(COUNT(*)) OVER ()) PERCENT2, -- gesamtanzahl OVER leer
    MIN(COUNT(*)) OVER (PARTITION BY DEPARTMENT_ID) MIN,
    MAX(COUNT(*)) OVER (PARTITION BY DEPARTMENT_ID) MAX
FROM STUDENT,
     SCHOOLCLASS
WHERE STUDENT.SCHOOLCLASS_ID = SCHOOLCLASS.SCHOOLCLASS_ID
GROUP BY SCHOOLCLASS.DEPARTMENT_ID,STUDENT.SCHOOLCLASS_ID,SCHOOLCLASS.NAME
ORDER BY SCHOOLCLASS.DEPARTMENT_ID,COUNT(*); -- SCHOOLCLASS.NAME;


select SCHOOLCLASS.NAME, TEACHER.SURNAME
from SCHOOLCLASS, TEACHER, DEPARTMENT
where DEPARTMENT.TEACHER_ID = TEACHER.TEACHER_ID
order by DEPARTMENT.DEPARTMENT_ID;


-- Indexe: Wenn die Tabellen SCHOOLCLASS, TEACHER und DEPARTMENT entsprechende Indexe auf den Spalten haben, die in den Join-Bedingungen und in der ORDER BY-Klausel verwendet werden, können diese Indexe effizient genutzt werden, um den Datenzugriff zu beschleunigen. Zum Beispiel könnten Indexe auf DEPARTMENT.TEACHER_ID, TEACHER.TEACHER_ID und DEPARTMENT.DEPARTMENT_ID hilfreich sein.

-- Ausführungsplan: Ein Ausführungsplan zeigt den Optimierer des Datenbanksystems an, wie die Abfrage ausgeführt werden soll. Je nach Datenverteilung, Größe der Tabellen und vorhandenen Indexen kann der Ausführungsplan variieren. Ein typischer Ausführungsplan für diese Abfrage könnte sein:

-- Einlesen der benötigten Daten aus den Tabellen DEPARTMENT und TEACHER unter Verwendung von Indexzugriffen auf DEPARTMENT.TEACHER_ID und TEACHER.TEACHER_ID.
-- Ausführung des Joins zwischen DEPARTMENT und TEACHER basierend auf den Join-Bedingungen.
-- Zusammenführen der Daten aus SCHOOLCLASS mit den bereits verbundenen Daten.
-- Sortieren der Ergebnisse nach DEPARTMENT.DEPARTMENT_ID gemäß der ORDER BY-Klausel.
